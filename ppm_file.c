#include "ppm_file.h"

#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

PpmColor rgb_black() {
  PpmColor result = {0};
  return result;
}

PpmColor rgb_white() {
  PpmColor result = {255, 255, 255};
  return result;
}

PpmColor ppm_color_from_color(Color color) {
  PpmColor result;
  result.r = (uint8_t)(CLAMP(color.x) * 255);
  result.g = (uint8_t)(CLAMP(color.y) * 255);
  result.b = (uint8_t)(CLAMP(color.z) * 255);
  return result;
}

static Color ppm2color(PpmColor c) {
  Color result;
  result.x = (double)c.r / 255.0;
  result.y = (double)c.g / 255.0;
  result.z = (double)c.b / 255.0;
  return result;
}

PixelMap *pixel_map_new(int width, int height) {
  PixelMap *ppm_file = malloc(sizeof(PixelMap));
  ppm_file->width = width;
  ppm_file->height = height;
  ppm_file->data = malloc(width * height * sizeof(PpmColor));
  memset(ppm_file->data, 0, width * height * sizeof(PpmColor));

  return ppm_file;
}

void pixel_map_destroy(PixelMap *f) {
  free(f->data);
  free(f);
}

// Writes value to PixelMap
// Returns 1 if success, 0 if invalid x y
int pixel_map_put(PixelMap *this, int x, int y, PpmColor value) {
  int pos = x + y * this->width;
  if (pos < this->width * this->height) {
    this->data[pos] = value;
    return 1;
  }
  return 0;
}

// Returns value located at x y pixel in PixelMap, 0 if invalid x y
PpmColor pixel_map_get(PixelMap *this, int x, int y) {
  int pos = x + y * this->width;
  if (pos < this->width * this->height)
    return this->data[pos];

  PpmColor empty = {.r = 0, .g = 0, .b = 0};
  return empty;
}

static void write_header(PixelMap *this, FILE *file) {
  char time_str[64];
  time_t now = time(0);
  struct tm *tm = localtime(&now);
  strftime(time_str, sizeof(time_str), "%c", tm);

  fprintf(file,
          "P3\n"
          "# generated by masptracer at %s\n"
          "%d %d\n"
          "255\n",
          time_str, this->width, this->height);
}

int pixel_map_write_to_ppm(PixelMap *this, const char *output_filename) {
  FILE *output_file = fopen(output_filename, "w+");
  if (!output_file)
    return errno;

  write_header(this, output_file);
  for (int i = 0; i < this->width * this->height; i++) {
    PpmColor c = this->data[i];
    fprintf(output_file, "%d %d %d\n", c.r, c.g, c.b);
  }
  int rc = fclose(output_file);
  if (rc != 0)
    return rc;
  return 0;
}

int pixel_map_read_from_file(const char *input_filename, PixelMap **out) {
  FILE *input_file = fopen(input_filename, "r");
  if (!input_file)
    return errno;

  int width, height;
  int max_value;
  int rc = fscanf(input_file, "P3 %d %d %d\n", &width, &height, &max_value);
  if (rc != 3 || width <= 0 || height <= 0 || max_value <= 0) {
    fprintf(stderr, "invalid header for ppm file\n");
    fclose(input_file);
    return EINVAL;
  }

  PixelMap *new_map = pixel_map_new(width, height);
  int r, g, b;
  int i = 0;
  while ((rc = fscanf(input_file, "%d %d %d", &r, &g, &b)) == 3) {
    if (i >= width * height) {
      fprintf(stderr,
              "too many pixels defined for ppm file (expected %d triplets)\n",
              width * height);
      pixel_map_destroy(new_map);
      fclose(input_file);
      return EINVAL;
    }
    PpmColor c = {r, g, b};
    new_map->data[i] = c;
    i++;
  }

  fclose(input_file);
  if (rc > 0) {
    fprintf(stderr,
            "invalid number of components (not divisible by three), ended with "
            "extra %d components\n",
            rc);
    pixel_map_destroy(new_map);
    return EINVAL;
  }

  *out = new_map;
  return 0;
}

Color pixel_map_nearest_lookup(PixelMap *this, Vec2 uv) {
  PpmColor c = pixel_map_get(this, (int)round(uv.x * (this->width - 1)),
                             (int)round(uv.y * (this->height - 1)));
  return ppm2color(c);
}
